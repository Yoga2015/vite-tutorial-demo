<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>全局自定义指令模拟v-model双向绑定</title>
    <script src="./vue.js"></script>
  </head>
  <body>
    <div id="app">
      <input type="text" v-model="message" />
      <input type="text" v-mydirective />
      <p>{{message}}</p>
    </div>

    <script>
      Vue.directive("mydirective", {
        bind(el, binding, vnode) {
          console.log(el);
          console.log(binding);
          console.log(vnode);
        },
        inserted(el, binding, vnode) {},
        update(el, binding, vnode, oldVnode) {},
      });
      new Vue({
        el: "#app",
        data() {
          return {
            message: "walking",
          };
        },
      });

      // 在Vue中实现自定义指令可以使用Vue.directive()方法，下面是一个例子来实现一个基础的双向绑定指令。
      // Vue.directive(name：表示指令的名称, directive（可选）：表示指令的定义。)
      //
      // Vue.directive("my-directive", {
      //   bind: function (el, binding, vnode) {
      //     // 监听input事件
      //     el.addEventListener("input", function (event) {
      //       // 更新数据
      //       vnode.context[binding.expression] = event.target.value;
      //     });
      //   },
      //   update: function (el, binding, vnode) {
      //     // 更新input的value属性
      //     el.value = vnode.context[binding.expression];
      //   },
      // });

      // new Vue({
      //   el: "#app",
      //   data: {
      //     message: "Hello World!",
      //   },
      // });

      // 在上面的代码中，我们定义了一个名为“my-directive”的指令。
      // 在bind hook函数中，我们监听了input事件。在事件处理程序中，我们将输入值更新到相关的数据属性上。
      // 在update hook函数中，我们更新input的value属性以反映数据的变化。
      // 因此，现在当用户在输入框中输入内容时，数据将自动更新并呈现在p标签中。
    </script>

    <script>
      import { createApp } from "vue";
      import App from "./App.vue";

      const app = createApp(App);
      // 全局注册自定义指令
      app.directive("directiveName", {
        // 在绑定元素的 attribute 或 事件监听器 被应用之前 调用,
        // 比如：在指令需要附加须要在普通的 v-on 事件监听器前调用的事件监听器时，这很有用
        created() {},
        // 当指令第一次绑定到元素并且在挂载父组件之前调用
        beforeMount() {},
        // 在绑定元素的父组件被挂载后调用
        mounted() {},
        // 在更新包含组件的 VNode 之前调用
        beforeUpdate() {},
        // 在包含组件的 VNode 及其子组件的 VNode 更新后调用
        updated() {},
        // 在卸载绑定元素的父组件之前调用
        beforeUnmount() {},
        // 当指令与元素解除绑定且父组件已卸载时, 只调用一次
        unmounted() {},
      });
    </script>

    <script>
      import Vue from "vue";

      Vue.directive("my-directive", {
        bind: function (el, binding, vnode) {
          // 指令第一次绑定到元素时被调用
        },
        inserted: function (el, binding, vnode) {
          // 元素插入到 DOM 中时被调用
        },
        update: function (el, binding, vnode, oldVnode) {
          // 元素更新时被调用
        },
        componentUpdated: function (el, binding, vnode, oldVnode) {
          // 元素及其子组件全部更新时被调用
        },
        unbind: function (el, binding, vnode) {
          // 指令从元素上解绑时被调用
        },
      });
    </script>
  </body>
</html>
